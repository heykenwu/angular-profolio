<div
  class="banner-innerpage"
  style="background-image: url(assets/images/project/portfor_logo.jpg)"
>
  <div class="container">
    <!-- Row  -->
    <div class="row justify-content-center">
      <!-- Column -->
      <div class="col-lg-9 col-md-6 no-trans align-self-center text-center">
        <h1 class="title">Port Forwarder</h1>
      </div>
      <!-- Column -->
    </div>
    </div>
</div>
<!-- ============================================================== -->
<!-- Feature 22  -->
<!-- ============================================================== -->
<div class="header_outer">
    <h2 class="header_t md-display-1">
    <strong >
        In this project, we are going to design and develop a network application that uses advanced TCP/IP programming techniques, and implement a "Port Forwarder" using C languange
    </strong>
    </h2>
</div>
<div class="container">
    <h1 class="md-display-3"><strong>Objective</strong></h1>
    <ul >
        <li>
          <h3 class="md-headline">
            To design and develop a network application that uses advanced TCP/IP programming techniques.
        </h3>
        </li>
        <li>
            <h3 class="md-headline">
            To design and implement a minimum-functionality "Port Forwarder" using any language of your choice.
            </h3>
        </li>
      </ul>
      <h1 class="md-display-3"><strong>Apporach</strong></h1>
      <h3 class="md-headline">
        First, we will create a c program that creates an epoll instance and assigned it will an IP/port pair. Upon receiving an external connection request, the epoll instance will handle the request, accepted it and add it to the monitoring list.
         The accept operation will be offload to multiple threads. We will implement this feature using OpenMP.
    </h3>
    <h3 class="md-headline">
        If the epoll instance receives data that is destined to an internal client on a connection established, it will remove that socket from the monitoring list, 
        and fork a child process to handle further communication between the external and internal client.
    </h3>
    <h3 class="md-headline">
        We will create a bash script to run the c program as deamon once for each of the IP port pairs defined in the config file.
    </h3>
    <h1 class="md-display-3"><strong>State diagram</strong></h1>
    <div class="design_img_container">
        <img class="design" src="assets/images/project/portforward_main.PNG">
        </div>
        <div class="caption">
        <em>figure 1 Main thread</em>
        </div>
    <div class="design_img_container">
        <img class="design" src="assets/images/project/portforward_child.PNG">
        </div>
        <div class="caption">
        <em>figure 2 Child thread</em>
        </div>
    <h1 class="md-display-3"><strong>Source code</strong></h1>
    <h3 class="md-headline">
        The project source code can be found <a href="">here</a>.
    </h3>
    <h1 class="md-display-3"><strong>Usage</strong></h1>
    <h3 class="md-headline">
        Name
        <br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>server</strong> "port" "hostname" "host-port"
    </h3>
    <h3 class="md-headline">
        Arguments
    </h3>
    <ul>
        <li>
          <h3 class="md-headline">
            <strong>port</strong>: server listening port 
        </h3>
        </li>
        <li>
            <h3 class="md-headline">
                <strong>hostname</strong>: internal client IP
            </h3>
        </li>
        <li>
            <h3 class="md-headline">
                <strong>host-port</strong>: internal client port
            </h3>
        </li>
      </ul>
      <h3 class="md-headline">
        <strong>Description</strong><br>
        This program bridges traffic between external clients and internal clients. For example, assuming the arguments are set to <strong>port</strong> = 80, 
        <strong>hostname</strong> = 192.168.0.2 and <strong>host-port</strong> = 8080, any incoming traffic on port 80 from external client will be redirect to 192.168.0.2 on port 8080
    </h3>
    <h1 class="md-display-3"><strong>How to run</strong></h1>
    <h3 class="md-headline">
        To quickly test the program, cd into the "executable" directory ,
         and run through <strong>Step 1</strong> and <strong>3</strong> only. If this does not work, cd into the "source" directory, and run through all <strong>Step 1 ~ 3</strong>.
    </h3>
    <h3 class="md-headline">
        <strong>Step 1</strong> : add IP/port pair in the setup.config file <br>
        <strong>Example</strong>: 7005 -> 192.168.0.1:8005 7006 -> 192.168.0.2:8006<br>
        In this example, the port forwarder will listen on both port 7005 and 7006. Any traffic destined to port forwarder on port 7005 will be redirected to the internal client 192.168.0.1 on port 8005. 
        Any traffic destined to port forwarder on port 7006 will be redirected to the internal client 192.168.0.2 on port 8006.
    </h3>
    <h3 class="md-headline">
        <strong>Step 2</strong> : compile the c program using the Makefile in the same directory<br><strong>$ make</strong>
    </h3>
    <h3 class="md-headline">
        <strong>Step 3</strong> : run the bash script "<strong>port-forward.sh</strong>". 
        This will run the c program up to the number of entries defined in the config file. The program will run the the background.<br><strong>$ ./port-forward</strong>
    </h3>
    <h3 class="md-headline">
        Finally, to stop the background process, run. This will stop the already running port-forwarder.<br><strong>$ ./stop-script</strong>
    </h3>
    <h1 class="md-display-3"><strong>Testing</strong></h1>
    <h3 class="md-headline">
        <strong>Case 1</strong>: In this case, we are testing the maximum active socket the server can handle in once session. We will keep adding external clients indefinitely until there's a significant degradation in performance on the server-side. Each spawned client will send an echo request to the server and wait for a reply, 
        this process will continue for enough time until the performance on the server-side drops.
    </h3>
    <h3 class="md-headline">
        <strong>Testing params</strong>
    </h3>
    <ul>
        <li>
          <h3 class="md-headline">
            20000 echo request (10000 each on two client machines)
        </h3>
        </li>
        <li>
            <h3 class="md-headline">
                10000 nano sec delay in between each echo request (not including the response time from the previous request)
            </h3>
        </li>
        <li>
            <h3 class="md-headline">
                0.0002-sec client spawn delay
            </h3>
        </li>
      </ul>
      <h3 class="md-headline">
        <strong>Monitoring tool</strong>: Wireshark<br>
        <strong>Results</strong> :
    </h3>
    <div class="design_img_container">
    <img class="design" src="assets/images/project/portf_test1.PNG">
    </div>
    <div class="caption">
    <em>figure 3 Wireshark Conversation</em>
    </div>
    <div class="design_img_container">
        <img class="design" src="assets/images/project/portf_test2.PNG">
        </div>
        <div class="caption">
        <em>figure 4 Wireshark I/O graph on server</em>
    </div>
    <h3 class="md-headline">
        In figure 1, we recorded that there were roughly 20000 active socket connections in one session by using epoll. And we found that if we kept the test longer as the number of active connections goes higher, the epoll server showed that the incoming packets dropped when the active socket count hits 20000 counts according to figure2. 
        We believed that the reason behind this was because the server was not able to reply back to the client as quickly as before, i.e. the server response time increased. The client will only send one request when the previous request is answered.
    </h3>   
    <h3 class="md-headline">
        <strong>Case 2</strong>: In this case, we try to verify if the server can handle multiple external traffics destined to multiple internal clients. In essence, 
        if there are two internal web servers, A and B, clients from outside should be able to request a web page content from either webserver A or B through the port forward server.
    </h3>  
    <h3 class="md-headline">
        <strong>Machine IPs</strong>:
    </h3>  
    <ul>
        <li>
          <h3 class="md-headline">
            192.168.0.44: Client
        </h3>
        </li>
        <li>
            <h3 class="md-headline">
                192.168.0.41: Forwarder
            </h3>
        </li>
        <li>
            <h3 class="md-headline">
                192.168.0.52: Internal HTTP Server
            </h3>
        </li>
        <li>
            <h3 class="md-headline">
                192.168.0.53: Internal HTTP Server
            </h3>
        </li>
      </ul>
    <h3 class="md-headline">
        <strong>Testing params</strong>:
    </h3> 
    <ul>
        <li>
          <h3 class="md-headline">
            192.168.0.44 connects to 192.168.0.52 (Port 8008) through 192.168.0.41 (Port 8005)
        </h3>
        </li>
        <li>
        <h3 class="md-headline">
            192.168.0.44 connects to 192.168.0.53 (Port 8009) through 192.168.0.41 (Port 8006)
        </h3>
        </li>
      </ul>
      <h3 class="md-headline">
        <strong>Monitoring tool</strong>: Wireshark<br>
        <strong>Results</strong> :
    </h3> 
    <div class="design_img_container">
        <img class="design" src="assets/images/project/portf_tcp_server.PNG">
        </div>
        <div class="caption">
        <em>figure 5 TCP conversation (192.168.0.52 HTTP Server)</em>
    </div>
    <div class="design_img_container">
        <img class="design" src="assets/images/project/portf_wireshark_server.PNG">
        </div>
        <div class="caption">
        <em>figure 6 Wireshark capture (192.168.0.52 HTTP Server)</em>
    </div> 
    <h3 class="md-headline">
        According to Figure 1, we can see that the client is trying to send requests from high port to the HTTP Server (192.168.0.52) on port 8009 over port 8006 on Port Forwarder. Look at the pcap for detailed info (Figure 2), we find that the client sent an HTTP GET request after doing a three-way handshake with the Port Forwarder (no. 111) . Forwarder then forwarded the request to the HTTP server. When it finishes the tree-way handshake with HTTP Server on port 8009 (no. 116),
         HTTP server then sent the result back to the Port Forwarder after receiving the GET request (no. 118). Finally, the Port Forwarder sent backt the result to the client (no.120).
    </h3>
    <div class="design_img_container">
        <img class="design" src="assets/images/project/portf_tcp_53.PNG">
        </div>
        <div class="caption">
        <em>figure 7 TCP conversation (192.168.0.53 HTTP Server)</em>
    </div>
    <div class="design_img_container">
        <img class="design" src="assets/images/project/portf_wireshark_53.PNG">
        </div>
        <div class="caption">
        <em>figure 8 Wireshark capture (192.168.0.53 HTTP Server)</em>
    </div> 
    <h3 class="md-headline">
        After that, the client starts to access the second HTTP server (192.168.0.53) via the Port Forwarder. We can see that in Figure 3, the client sent packets from high port to Port Forwarder on port 8005 . The Port Forwarder then forwarded the packets to the HTTP server (192.168.0.53) on port 8008 of. In Figure 4, we can see that after the client finished three-way handshake with the Port Forwarder, the client started sending HTTP GET request to the Port Forwarder on port 8005(no. 76).
         Port Forwarder then forwarded the GET request to the HTTP server (no.81). The HTTP server sent the result back to the Port Forwarder (no.83).</h3>
</div>