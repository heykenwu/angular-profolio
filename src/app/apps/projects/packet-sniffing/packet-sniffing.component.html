<div
  class="banner-innerpage"
  style="background-image: url(assets/images/project/ps_banner.jpg)"
>
  <div class="container">
    <!-- Row  -->
    <div class="row justify-content-center">
      <!-- Column -->
      <div class="col-lg-9 col-md-6 no-trans align-self-center text-center">
        <h1 class="title">Linux packet-sniffing application</h1>
      </div>
      <!-- Column -->
    </div>
    </div>
</div>
<!-- ============================================================== -->
<!-- Feature 22  -->
<!-- ============================================================== -->
<div class="header_outer">
    <h2 class="header_t md-display-1">
    <strong >
        In this project, we are going to design and implement a packet sniffing backdoor. The backdoor is essentially a
        communication channel between a victim’s machine and a attacker's machine.
    </strong>
    </h2>
</div>
<div class="container">
    <h1 class="md-display-3"><strong>Constraint</strong></h1>
    <ul>
        <li>
            <h3 class="md-headline">Backdoor must camouflage itself so as to deceive anyone looking at the process table </h3>
        </li>
        <li>
            <h3 class="md-headline">Application must ensure that it only receives (authenticate) those packets that are meant 
            for the backdoor itself.</h3>
        </li>
        <li>
            <h3 class="md-headline"> The backdoor must interpret commands sent to it and execute them and send the results back</h3>
        </li>
        <li>
            <h3 class="md-headline">Incorporate an encryption scheme of your choice into the backdoor</h3>
        </li>
        </ul>
<h1 class="md-display-3"><strong>Approach</strong></h1>
<h3 class="md-headline">We will use the c library <strong>libpcap</strong> to implement the backdoor. To make the process of
    communicating with the backdoor more intuitive, we will also write a remote access
    client. To issue a command to the backdoor, the remote client will send a UDP packet to
    the backdoor. The payload of that packet has a predefined keyword followed by a
    ciphertext of the actual command to be executed on the backdoor. The key used to
    create the ciphertext is shared with the backdoor program.
    Network traffic capturing happens before the firewall, therefore, the backdoor will still be
    able to sniff the incoming packet even if there’s a blocking rule in place. When the
    backdoor receives the UDP packet, it will check the keyword in the payload to verify that
    the packet is indeed from the remote client. Next, it will proceed to decrypt the
    encrypted command, execute the command, and send the output of the command back
    to the remote client in TCP. The figures below show a sample of the UDP payload, and a
    high level overview of the communication process.</h3>
    <div class="design_img_container">
        <img class="payload_design" src="assets/images/project/ps_payload.PNG">
    </div>
    <div class="caption">
    <em>figure 1 remote client UDP payload</em>
    </div>
    <div class="design_img_container">
        <img class="process_design" src="assets/images/project/ps_process.PNG">
    </div>
    <div class="caption">
    <em>figure 2 overview of the backdoor communication process</em>
    </div>
    <h1 class="md-display-3"><strong>Application design</strong></h1>
    <h3 class="md-headline">The backdoor has four component:</h3>
    <ul>
        <li>
            <h3 class="md-headline"><strong>backdoor.c</strong>: program entry point. Responsible for running packet sniffing. Has a
                callback function that invokes the packet handling function (in packet_handler.c)
                and command result returning function (in tcp_sender.c)
                </h3>
        </li>
        <li>
            <h3 class="md-headline"><strong>packet_handler.c</strong>: consists of a single function packet_handler(). The function is
                responsible for three things: determining whether the sniffed packet is for the
                backdoor or not, executing the received command, and writing the result of the
                command execution to a temporary file.
                </h3>
        </li>
        <li>
            <h3 class="md-headline"><strong>tcp_sender.c</strong>: consists of a single function send_output(). The function
                establishes TCP connection back to the remote client, and sends the content of
                the temporary file back to the remote client. The temporary is generated by the
                packet handler.</h3>
        </li>
        <li>
            <h3 class="md-headline"><strong>config.h</strong>: some defined constants, important ones including </h3>
            <ul>
                <li>
                    <h3 class="md-headline"><strong>BACKDOOR_HEADER_KEY</strong>: keyword for identifying packet for backdoor</h3>
                </li>
                <li>
                    <h3 class="md-headline"><strong>PASSWORD</strong>: use for data encryption</h3>
                </li>
                <li>
                    <h3 class="md-headline"><strong>SNIFFER_FILTER</strong>: filter to apply when using the pcap functions</h3>
                </li>
                <li>
                    <h3 class="md-headline"><strong>CLIENT_IP</strong>: remote client ip</h3>
                </li>
                <li>
                    <h3 class="md-headline"><strong>CLINET_PORT</strong>: remote client tcp listening port</h3>
                </li>
            </ul>
        </li>
        </ul>
        <h3 class="md-headline">The remote client has two component:</h3>
        <ul>
                <h3 class="md-headline">
                    <li>
                        <h3 class="md-headline"><strong>client.c</strong>: program entry point. Responsible for sending commands to the
                            backdoor, and listening for result return from backdoor.
                            </h3>
                    </li>
                    <li>
                        <h3 class="md-headline"><strong>config.h</strong>: some defined constants, important ones including</h3>
                        <ul>
                            <li>
                                <h3 class="md-headline"><strong>BACKDOOR_HEADER_KEY</strong>: keyword for identifying packet for backdoor</h3>
                            </li>
                            <li>
                                <h3 class="md-headline"><strong>PASSWORD</strong>: use for data encryption</h3>
                            </li>
                            <li>
                                <h3 class="md-headline"><strong>SEND_PORT</strong>: the port that backdoor is sniffing on</h3>
                            </li>
                            <li>
                                <h3 class="md-headline"><strong>CLIENT_PORT</strong>:tcp listening port, for reading result
                                </h3>
                            </li>
                            <li>
                                <h3 class="md-headline"><strong>BACKDOOR_IP</strong>: ip of the machine running backdoor</h3>
                            </li>
                        </ul>
<h1 class="md-display-3"><strong>State diagram</strong></h1>
<div class="design_img_container">
    <img class="process_design" src="assets/images/project/ps_bd.PNG">
</div>
<div class="caption">
<em>figure 3 backdoor</em>
</div>
<div class="design_img_container">
    <img class="process_design" src="assets/images/project/ps_rc.PNG">
</div>
<div class="caption">
<em>figure 4 remote client</em>
</div>
<h1 class="md-display-3"><strong>Pseudo implementation</strong></h1>
<h3 class="md-headline"><strong>BACKDOOR</strong></h3>
<div class="design_img_container">
    <img class="process_design" src="assets/images/project/ps_bd_su.PNG">
</div>
<div class="caption">
<em>figure 5 backdoor.c</em>
</div>
<div class="design_img_container">
    <img class="process_design" src="assets/images/project/ps_bd_su2.PNG">
</div>
<div class="caption">
<em>figure 6 packet_handler.c</em>
</div>
<div class="design_img_container">
    <img class="process_design" src="assets/images/project/ps_bd_su3.PNG">
</div>
<div class="caption">
<em>figure 7 tcp_sender.c</em>
</div>
<h1 class="md-display-3"><strong>Usage</strong></h1>
<h3 class="md-headline"><strong>Step 1</strong></h3>
<h3 class="md-headline">Open the <strong>config.h</strong> in backdoor folder, edit the value of following constant:</h3>
<ul>
    <li>
        <h3 class="md-headline"><strong>BACKDOOR_HEADER_KEY</strong>: key to authenticate the packet</h3>
    </li>
    <li>
        <h3 class="md-headline"><strong>BACKDOOR_HEADER_LEN</strong>: length of the header key</h3>
    </li>
    <li>
        <h3 class="md-headline"><strong>PASSWORD</strong>: password for encrypting execution result before sending back</h3>
    </li>
    <li>
        <h3 class="md-headline"><strong>PASSLEN</strong>: length of the password</h3>
    </li>
    <li>
        <h3 class="md-headline"><strong>SNIFFER_FILTER</strong>:pcap filter</h3>
    </li>
    <li>
        <h3 class="md-headline"><strong>NIC_NAME</strong>: name of the network interface to sniff on</h3>
    </li>
</ul>
<h3 class="md-headline"><strong>Step 2</strong></h3>
<h3 class="md-headline">Open the <strong>config.h</strong> in remote_client folder, edit the value of following constant:</h3>
<ul>
    <li>
        <h3 class="md-headline"><strong>BACKDOOR_HEADER_KEY</strong>: key to authenticate the packet</h3>
    </li>
    <li>
        <h3 class="md-headline"><strong>BACKDOOR_HEADER_LEN</strong>: length of the header key</h3>
    </li>
    <li>
        <h3 class="md-headline"><strong>PASSWORD</strong>: password for encrypting execution result before sending back</h3>
    </li>
    <li>
        <h3 class="md-headline"><strong>PASSLEN</strong>: length of the password</h3>
    </li>
    <li>
        <h3 class="md-headline"><strong>BACKDOOR_PORT</strong>: port number the backdoor is sniffing on</h3>
    </li>
    <li>
        <h3 class="md-headline"><strong>CLIENT_PORT</strong>:  tcp port to listen on, for receiving result from backdoor</h3>
    </li>
    <li>
        <h3 class="md-headline"><strong>BACKDOOR_IP</strong>: ip of the machine running backdoor</h3>
    </li>
</ul>
<h3 class="md-headline"><strong>Step 3</strong></h3>
<h3 class="md-headline">To run the backdoor in a terminal, cd into the backdoor folder. then run “<strong>make all</strong>”. The
    Makefile will compile, clean and automatically run the executable.</h3>
<h3 class="md-headline">To run the remote client in a terminal, cd into the backdoor folder, then run “<strong>make all</strong>”.
    The Makefile will compile, clean and automatically run the executable. The terminal
    should prompt you for input. Type a command and press enter (e.g. ifconfig). If all things
    are configured correctly, and the backdoor is running, the terminal running remote client
    should receive the some result return from the backdoor.
    </h3>
    <h1 class="md-display-3"><strong>Source Code</strong></h1>
    <h3 class="md-headline">The source code is <a href="">here</a>
        </h3>